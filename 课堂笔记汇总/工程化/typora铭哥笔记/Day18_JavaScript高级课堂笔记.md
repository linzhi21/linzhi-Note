# Day18 JavaScript 高级课堂笔记

## 1 JavaScript 中的垃圾回收机制（GC）

### 1.1 垃圾回收相关概念

#### ① 什么是垃圾

```
没有被引用的对象，就是垃圾对象。
```

#### ② 什么是垃圾回收

```
1. 销毁垃圾对象，释放内存，称为垃圾回收。
2. 像C、C++ 等编程语言需要手动回收垃圾。
3. 像Paython、JavaScript、Java 等编程语言自动回收。
```

#### ③ 变量的生命周期（何时会被回收）

```
1. 修改变量的值，变量不再引用某个对象，该对象变为垃圾
2. 执行执行结束，变量自动销毁，原来所指向的对象不再被引用，变为垃圾。
```

#### ④ 垃圾没有及时回收的后果

```
1. 垃圾对象没有被清除，导致内存空间被占用, 造成内存泄。
2. 内存空间越占越多，导致程序卡顿甚至死机。
```

#### ⑤ JavaScript 垃圾回收的常见算法

### 1.2 引用计数

#### ① 原理

```
1. 每个对象都有一个引用标记
2. 增加对该对象的引用（给变量或属性赋值），该对象的引用标记+1
3. 减少对该对象的引用（变量或属性该值，变量属性被销毁），，该对象的引用标记-1
4. 当引用标记为 0 的时候，该对象变为垃圾对象，被回收
```

#### ② 优缺点：

```
1. 垃圾回收及时，计算效率高
2. 互相引用的两个对象，会永远无法被销毁，常驻内存，造成内存泄漏
```

### 1.3 标记清除

#### ① 原理

```
1. 系统不断循环执行标记清除操作
2. 每次标记清除分为两个阶段：
   -标记阶段：从全局对象开始，向下遍历属性以及属性的属性（树状递归遍历），能够访问到的对象，进行标记，称为可访问对象。
   -清除阶段：线性遍历内存中所有的对象，将没有标记的对象就是垃圾，进行回收。
3. 下一轮去掉所有对象的标记，进行重新标记清除
```

#### ② 优缺点

```
1. 所有的垃圾对象都可以被回收，不会造成内存泄漏
2. 不停地循环进行进行树状递归遍历，执行效率相对较低
```





## 2 执行上下文和执行栈

### 2.1 执行上下文

#### ① 全局执行上下文

```
1. 在执行执行代码之前，创建全局执行上下文对象，确定window就是全局执行上下文对象。
2. 对全局数据进行预处理
   ① 查找代码中 var 关键字定义的变量，添加为 window 的属性， 不进行赋值。
   ② 查找代码中 function 关键字定义的函数，添加为 window 的方法（属性名是函数名，属性值就是函数体）。
   ③ 创建 this，赋值为 window
3. 正式执行全局代码
```

#### ② 函数内的执行上下文

```js
1. 调用函数的时候，执行函数体中代码之前，创建执行上下文对象。
2. 对函数中的数据进行预处理：
   ① 对形参进行赋值，将形参添加为执行上下文对象的属性。
   ② 创建 arguments 并进行赋值，将 arguments 添加为执行上下文对象的属性。
   ③ 查找函数代码中，var 关键字定义的变量，添加为执行上下文对象的属性，不进行赋值。
   ④ 查找函数代码中，function 关键字定义的函数，添加为执行上下文对象的方法（属性名是函数名，属性值就是函数体）。
   ⑤ 创建this，赋值为调用该函数的对象
3. 正式执行函数体代码。
```

> **强调：** 函数没调用一次，就创建一个执行上下文对象。

### 2.2 执行栈

**执行栈：** 也叫调用栈，是一种栈数据结构，用来存储代码执行过程中所创建的执行上下文对象。

**栈结构：** 是一种数据存结构，特点是先进后出，后进先出。将数据放入栈栈结构称为**进栈**，栈结构中的数据销毁称为**出栈**。

### 2.3 作用域和执行上下文的关系

**区别：**

```
1. 作用域是静态的，在函数声明的时候，函数中的变量就已经确定了作用域。
2. 执行上下文对象是动态的，没调用一次函数，就创建一个执行上下文对象。
```

**联系：**

```
执行上下文对象同样具有作用域：
全局执行上下文对象 -> 全局
函数中的执行上下文对象 -> 函数
```





## 3. 闭包

### 3.1 什么是闭包？

```
1）简单讲，闭包就是指有权访问另一个函数作用域中的变量的函数。
2）MDN 上面这么说：闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。
```

### 3.2 如何产生闭包

```
1. 在函数A的里面定义函数B
2. 函数B中使用函数A中（函数A是函数B的上层作用域）的数据
3. 将函数B被外部引用，如下三种方式可以让函数B被外部引用
   ① 将函数B作为函数A的返回值
   ② 将函数B设置为全局对象（window）的属性
   ③ 将函数B作为异步操作（DOM事件、定时器）的回调函数。
```

```js
function A() {
    var x = 100;
    function B() {
        console.log(x);
    }
    return B;
}

var res = A();
res();
```

### 3.3 闭包和作用域

```
1. 下层作用域可以使用上层作用域的数据
2. 作用域只与函数声明的位置有关，有函数在哪里调用无关！
```

### 3.4 闭包和垃圾回收

```js
1. 闭包让某个数据，即使函数调用结束，也仍然被引用；函数被销毁该数据仍然不会变为垃圾对象
2. 闭包延长了局部变量的生命周期
```

### 3.5 闭包的缺点

```
1. 闭包会导致数据长时间占用内存，提高内存泄漏的风险
2. 闭包慎重使用
```

### 3.6 闭包的应用

```
1. 通过遍历，给多个元素监听事件，闭包可以让事件回调函数中获取到元素的索引
2. 实现JS的模块化
```





## 作业

```
1. 复习原型链
```









