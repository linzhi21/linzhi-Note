## 1 原型

### 1.1 原型的概念

```
1. 每一个对象都有原型，原型也是个对象
2. 对象可以继承它原型上的属性和方法
```

### 1.2 如何获取对象的原型

**从对象的角度：**

```js
对象.__proto__
```

**从构造函数的角度：**

```js
构造函数.protptype
```

> **注意：** 通过该方式获取的不是构造函数的原型，是构造函数实例的原型。

### 1.3 对象、构造函数、原型之间的关系

#### ① 对象和构造函数

```
1. 对象是构造函数的实例；构造函数是对象的描述（抽象）。
2. 一个对象只有一个构造函数，一个构造函数可以有多个对象。
```

#### ② 对象和原型

```
1. 对象可以继承原型上的属性（包括方法）
2. 对象的原型只能有一个， 原型对象可以是多个对象的原型
```

#### ③ 构造函数和原型

```
1. 构造函数相同的对象，原型也相同
2. 函数.protptype 获取的是构造函数的实例的原型，称为构造函数的显示原型
   函数.__proto__, 获取的是自身的原型，等同于 Function.prototype; 称为构造函数的隐式原型。
```

### 1.4 自定义构造函数时原型的应用

```js
 // 自定义构造函数
function User(name, address) {
    // 设置属性 属性设置到对象本身上
    this.name = name;
    this.address = address;
}

// 在User实例的原型上设置方法
User.prototype.addShopcart = function(product) {
    console.log(this.name + '将' + product + '加入购物车');
};

User.prototype.buy = function(product) {
    console.log(this.name + '购买了'+ product + ', 收货地址' + this.address);
}
```

```
1. 将属性设置到对象本身上，因为同类型的对象都具有相同的属性，但是属性名各不相同
2. 将方法设置到对象的原型上，因为同类的对象方法也往往都是一样，设置到原型上可以节省内存空间。
```

### 1.5 判断属性是否属于对象本身

```js
对象.hasOwnProperty('属性名');
```

```
1. 如果属性在对象本身上，方法返回true
2. 如果属性在原型上或者属性不存在，方法返回 false
```



## 2 原型链

### 2.1 原型链

```
1. 每个对象都有原型，原型也是对象，原型也有原型，组成了一个原型链
2. 原型链的终点是一个没有原型的对象（顶层原型）， Object.prototype
```

### 2.2 原型链的作用

原型链用来描述属性的查找过程：

```
1. 当使用对象的某个属性的时候，先从对象本身查找，如果本身有该属性，就使用该属性，如果本身没有该属性，取对象的原型上查找
2. 如果对象的原型上还没有该属性，继续找原型的原型，直到顶层原型
3. 没有找到属性，自动得到 undefined
```

### 2.3 原型链和构造函数

```
1. Array、Object、Number、String、Boolean 以及所有的函数（构造函数），它们的构造函数都是 Function。
2. Function.prototype === Function.__proto__;   Function 的构造函数是 自己。
```





## 3 值类型和引用类型

**值类型：**  值类型也叫原始类型、基础类型、不可变类型，传值方式是值传递。

**引用类型：** 引用类型也叫对象类型、复合类型、可变类型，传值方式是引用传递。

**二者区别：**

```
1. 内存存储方式
   ① 值类型将数据存储在栈结构中
   ② 引用类型数据存储在堆结构中，栈结构中存储的是地址

2. 赋值方式（传值方式）
   ① 值类型传递的是值
   ② 引用类型传递的是地址

3. 可变和不可变
   ① 值类型是不可变类型，是一个整体，不可以修改其中的一部分
   ② 引用类型是可变类型，可以修改其中的一个属性，某个属性被修改，对象还是原来的对象
   
4. 判等方式
   ① 值类型比较的是值
   ② 引用类型比较的是地址
```







