14、收集添加和修改spu数据
	无论是展示数据还是收集数据，都在修改当中完成即可，修改完成了，添加就完成了

	收集前面三个v-model直接收集的，已经可以收集到位了，vmodel本来除了展示还有收集的作用

	收集图片列表
		无论是添加图片还是删除图片都要收集最新的图片列表，两个回调函数搞定 on-remove和on-success
		收集的图片并没有收集到位，而是放在外面的spuImageList当中，后期我们需要整理再放到spuForm里面
		才算到位

		注意：老的图片和新的图片，对象的属性结构是不一样的
		如果是老的图片
			id:43
			imgName:"41550ab1f3f369df.jpg"
			imgUrl:"http://47.93.148.192:8080/group1/M00/02/DB/rBHu8mGxPcKAA4kQAAAjnj5T1_M968.jpg"
			name:"41550ab1f3f369df.jpg"
			spuId:6
			status:"success"
			uid:1661581208578
			url:"http://47.93.148.192:8080/group1/M00/02/DB/rBHu8mGxPcKAA4kQAAAjnj5T1_M968.jpg

		如果是新添加的图片
			name:"3.jpg"
			percentage:100
			raw:File
			response:{
				data
			}
			size:74951
			status:"success"
			uid:1661581229399
			url:"blob:http://localhost:3000/0a1582ad-9c2d-4719-8195-b68138b16a98"

		老的图片当中有name和url也有imgName和imgUrl 而且都是正确的，路径都是网络路径
		新的图片当中只有name和url，没有imgName和imgUrl，而且url还是错的，它是本地路径
		因此，这里就告诉我们后面保存的时候，需要把图片列表整理完善之后，再放到spuForm去发请求

	收集添加销售属性 
		什么就是添加销售属性
			1》本质就是往spuSaleAttrList内部添加一个销售属性的对象
			2》添加销售属性的对象结构是什么？
				{
				  baseSaleAttrId?: number,
				  saleAttrName: string,
				  spuSaleAttrValueList:[] //应该是空数组
				}
				id?: number, //不需要的，添加销售属性，是没id的
				spuId?: number, //不需要的，添加spu的时候，是没有spuId的
			3》如何获取销售属性对象
				收集数据形成这个对象



		收集添加销售属性的过程
			1、用户点击select选择
				用户选择一个未使用的销售属性，此时我们就要收集这个销售属性的id和name到saleAttrIdName，id对应的就是对象结构当中的baseSaleAttrId，name对应的就是对象解构当中的saleAttrName，对象结构当中的spuSaleAttrValueList是空数组，因为新添加销售属性还没有添加销售属性值呢

			2、用户点击按钮
				当用户点击按钮的时候，对应的是一个回调函数，我们在回调函数当中，需要把刚刚收集的
				id和name，拿到构造成需要的销售属性对象结构，添加到指定的位置spuSaleAttrList




	收集添加销售属性值
		什么是添加销售属性值
			1》本质就是往row.spuSaleAttrValueList当中添加一个销售属性值对象

			2》添加销售属性的对象结构是什么？
				{
				  baseSaleAttrId?: number,  //需要 代表属性值所属属性的id，给哪个属性加属性值
				  saleAttrValueName:string, //需要 代表属性值的名称
				}
				id?: number, //不需要，因为新添加的销售属性值对象没有id
			    isChecked: string,//不需要，因为这个数据后台不需要
			    saleAttrName: string,//不需要，因为有了销售属性的id，就知道给哪个销售属性添加属性值
			    spuId?: number//不需要 新添加spu的时候没有id


			3》如何获取销售属性对象
				收集数据形成这个对象

		收集添加销售属性值的过程
			1、首先销售属性值里面input和添加按钮，同时只能显示一个，我们是vif进行判断row.isEdit
				为什么把isEdit挂在row身上，是因为在这里和平台属性不一样，平台属性当中是每个属性值
				都有自己的编辑模式和查看模式，是可以修改属性值的
				在这里，每个属性值是没有自己的编辑模式和查看模式，因为不需要修改属性值，如果要修改
				就删除后重新添加。所以，每个销售属性只有一个input和按钮，因此最终我们把模式数据添加
				到row身上（当前的销售属性身上）

			2、用户点击添加按钮，让按钮切换为input（修改row.isEdit），并且自动获取焦点

			3、变为input之后，用户输入数据，我们把用户输入的数据收集起来，暂存在row.saleAttrValueName身上

			4、用户就要失去焦点或者回车，此时我们就可以在回调当中把刚才暂存的row.saleAttrValueName数据拿到，判断成功之后
			整理成需要的属性值对象格式，添加到指定的位置row.spuSaleAttrValueList当中，同时把原本的输入框当中数据清空
			变为添加按钮




15、删除spu的销售属性值和删除spu的销售属性

	注意下标

16、	保存操作
	整理数据
		 1>整理category3Id，修改里面是有的，但是添加里面需要收集，因此不管是修改还是添加都给一个
 			需要从store当中去拿
  		 2>整理图片列表
  			新老图片格式上面有
  		 3>整理spu的销售属性列表
  		  删除每个销售属性身上的 isEdit和saleAttrValueName



1、添加或修改spu界面按钮的可操作性处理
2、删除spu的操作







3、添加sku功能
	点击列表页的添加sku按钮会去到添加sku页面skuForm页面
	实现skuForm的静态页面
	点击取消返回到列表页
	观察skuForm页面需要点击的spu的名称，因此我们在列表页也需要把spu传递给skuForm页面
	skuForm页面跳转过去也有初始化数据展示，mounted的时候需要发请求获取初始化动态数据

	初始化展示动态数据

	收集数据
		定义skuForm，因为是添加不需要id
		把要收集的数据进行分类
		收集平台属性值列表
			收集到哪
				最终是要收集到skuForm.skuAttrValueList

			收集的是什么结构
				{
				  attrId?: number, 需要的，因为需要知道拿哪个属性
				  valueId?: number,需要的，需要知道拿哪个属性值
				}


				id?: number,   不需要，新添加属性值，不需要id
				skuId?: number, 不需要 新添加sku是没有skuId的
			  	attrName: string,不需要 拿到id就可以找到到整个属性
			  	valueName: string 不需要 拿到id就可以找到整个属性值

			怎么获取到这个结构
				当用户点击select去选择平台属性值的时候，我们就得赶紧把用户选中的平台属性值的id及当前平台属性的id，拼接起来，先挂到当前平台属性身上的attrIdValueId，这样的话，哪个平台属性被选择了，那么哪个平台属性身上就会有
				attrIdValueId属性，没被选择的平台属性身上是没有这个attrIdValueId属性的

				但是目前我们并没有直接收集到位，而是临时先挂在各个属性身上，后期保存的时候
				遍历平台属性列表，看谁身上有attrIdValueId，那么就把它拿下来，做成需要的对象
				结构，添加到指定的数组当中



		收集销售属性值列表
			和上面收集平台属性值列表类似



		收集sku的图片列表和默认图片
			收集图片列表，也是没有收集到位，只是先放在外面自己定义的skuImageList当中
			后期保存也需要整理，再放进去

			默认图片是在写排它的时候，收集到位的

	保存逻辑
		整理数据
			整理图片列表
			整理平台属性值列表
			整理销售属性值列表
			整理3id tmId 和 spuId

4、查看spu的sku列表功能
	dialog的静态搭建
	点击按钮显示dialog
	保存点击的spu，用于展示dialog的title
	请求前的loading加载效果
	请求获取sku的列表
	请求完取消loading加载
	动态展示sku列表数据
	关闭前，清空sku列表



5、完成三级联动的可操作性
	:disabled = "showState !== 1"




一、scoped的作用及深度作用选择器（面试点）

scoped的作用
	scoped本意是作用域的意思，在style身上添加scoped是在限制这个style的样式作用域

	如果style当中没有添加scoped，那么内部所写的样式会影响其它组件
		如果其它组件当中也有和这个组件一样的选择器，那么选中的元素也会被影响到（整个页面）

	如果style当中添加scoped，那么内部所写的样式被限定了作用域
		在style当中添加了scoped会让样式作用域被限定在本组件内部和子组件的根标签
		如果子组件的根标签和样式的选择器一样，那么也能被影响到


		

原理是什么（怎么做到的）
	如果style添加scoped，那么它是靠添加标识数据来限定作用域的
	添加了scoped，本组件的所有元素以及子组件的跟标签，最后解析完都会添加一个data-v-xxxx
	的一个标识数据，只要有这个标识数据，就代表样式，可以影响到这些区域

	虽然这样能确定style当中的样式会影响到哪，但是还要保证元素的选择器是正确的，才能生效


	总结：想让一个元素有样式必须符合两个条件

	1、scoped能够作用到，也就是添加标识数据
	2、样式的选择器必须能选择到




	具体实现其实就是用css选择器来限定样式，把标识数据作为元素的一个特殊属性
	如果不添加scoped，样式最终是
	h2:{
		color:hotpink
	}

	如果加了scoped，样式最终是

	h2[data-v-38fc2d66] {
	    color: hotpink;
	}



有些组件标签添加样式就可以生效，有些组件添加样式就不能生效
	生效的样式，我们样式的作用域一定是作用到了       恰好选择器选中的就是组件的根标签
	没生效的样式，我们样式的作用域一定是没作用到     选择器选中的根本不是组件的根标签，而是子组件根标签内部的元素



如何解决？
	1、把不生效的样式不加scoped，重新写一个style
		样式是没有作用域限定的，也就是说子组件里面不管什么元素，只要选择器符合就可以生效

		一般使用的比较少，因为在使用的时候需要限定区域，不能让整个页面所有相关的元素，全部改变

	2、在加scoped的style中使用深度作用选择器 ***************************************
		让选择器发生改变，继续往子组件根标签内部的元素身上去选

		深度作用选择器，在vue2当中去使用的时候和vue3当中使用的时候是不一样de

		vue3中，我们需要用 :deep(需要的样式选择器)

		vue2中：
			采用在需要的选择器前面  ::v-deep

		原生的写法：要用父元素选择器  >>> 需要的选择器    一般不用


        深度作用选择器最终也是通过改变样式选择器来达到目标的

        	如果加了scoped没有使用深度作用选择器，那么我们的样式

        		h2[data-v-38fc2d66] {
				    color: hotpink;
				}

			如果加了scoped也使用了深度作用选择器，那么我们的样式

				[data-v-38fc2d66] h2 {
				    color: hotpink;
				}

			一句话，如果不用深度选择器，那么标识数据属性选择器是在最右边的，和自己的选择器组成交集选择器，就选择不到
			       如果使用深度选择器，那么标识数据属性选择器是在左边的，和自己的选择器组成后代选择器，就可以被选择到
