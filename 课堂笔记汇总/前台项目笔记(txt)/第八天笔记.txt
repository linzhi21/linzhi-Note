

	早上复习
	
		如何处理 Vue Router 的滚动行为
	
	
	今日目标
	
		① 加入购物车
		
		② 需要在加入购物车成功页面展示添加的商品
		
		③ uuid 生成一个唯一标识
		
		④ 购物车
		
			购物车数据获取、渲染
			
			单选和全选
			
			单个删除 和 批量删除
			
			购买的个数 以及 总价格
			
			限制购买的数量
	
	
	课程内容
	
	
	3. 加入购物车-发起请求
	
		点击加入购物车，只要【发请求】，就能够将商品放到购物车中
		
		① 看接口文档，封装接口 API，对应的功能模块文件中
		
		② 在组件中进行导入 API
		
		③ 点击加入购物车，调用 API
		
		
		
	4. 收集加入购物车成功页面使用的数据
	
		因为购物车成功页面没有接口，
		
		所以需要在详情页收集好数据，携带到 购物车成功页面
		
		经过分析：需要收集 5 个数据 (商品图片、名字、规格、购买数量、价格)
		
		在哪里收集：点击加入购物车的时候进行数据收集，而且是加入购物车成功以后
	
	
	5. 跳转到成功以后的页面 并 传参
	
		配置 购物车成功页面 路由和组件
	
	
	   参数应该怎么传递：
	   
		① 通过路由传参：行不通，因为路由不能传递对象类型的数据：array、{}
		
		② 使用 Vuex：可行，但是比较麻烦
		
		③ 本地存储：可行，localStorage、sessionStorage，在当前位置：使用是 sessionStorage
		
				因为：数据不需要永久存储，只是在 购物车成功页面 临时展示一下，告诉用你添加成功了
	
	
	
	6. 购物车静态组件
	
		处理加入购物车成功页面的跳转
	
		① 准备购物车路由和组件
		
		② 给两个按钮添加跳转方式
		
			返回详情：需要使用编程式导航，因为在加入购物车成功页面每页商品的 id，直接使用 back() 回退即可
			
			
			
	7、 购物车-创建购物车分支
	
	
		git add .
		
		git commit -m xxx
		
		git checkout develop
		
		git merge feature/xxx 
		
		git checkout -b xxxx
		
		
		
	8. 购物车-获取购物车数据
	
		打开购物车页面，就需要获取购物车数据，进行渲染
		
		
		① 看接口文档，封装接口 API，对应的功能模块文件中
		
		② 在组件中进行导入 API
		
		③ 写一个 methods 方法，调用 API
		
		④ 需要在钩子函数中调用方法，获取数据、渲染页面
		
		
		注意：如果这样请求，购物车列表数据不会返回 ！！！！
		
		
		
	9. 购物车-理解并生成临时标识
	
	
		问题产生的原因：
		
			因为目前网站谁都可以访问，在添加商品到购物车以后，服务器不知道谁添加的商品。
		
			所以服务器不进行任何处理。
		
		
		-----
		
		如何解决上面这个问题呢 ？
		
			让服务器知道谁添加的商品即可
			
			① 登录，登录以后，服务器知道是谁添加了购物车
			
			② 给每个能访问的用户添加一个唯一的标识，是一个临时标识
			
			  只能服务器知道谁往购物车添加了商品，但是不能用来支付、结算
			  
			  
		-----
		
			查看两个案例，理解两种解决方案
			
			京东：只要添加商品到购物车，需要先登录，只有登录了才知道加入哪一个购物车，才知道谁要购买
			
			小米：给每个访问的用户，分配了一个唯一标识，使用标识记录访问的用户的行为，添加购物车
			
				  通过唯一标识添加了商品，服务器进行了记录，记录使用唯一标识添加商品到购物车
				  
				  然后你又通过这个唯一标识访问购物车，所以就把唯一标识对应的购物车商品返回给你
				  
				  
		-----
		
			如何添加唯一标识
			
			按照接口文档的要求，需要给每个接口添加请求头 userTempId
			
			只需要在请求拦截器位置添加 请求头，key 为 userTempId 即可
			
			userTempId 不能固定死一个字符串，因为固定以后，每个用户都是使用这一个固定死的字符串
			
			没有任何意义，每个用户能访问到彼此需要购买的商品
			
			
			
	10. 购物车-使用 uuid 生成临时标识
	
	
		导入的  uuidv4() 方法返回的值不能直接给 userTempId
		
		为什么
	
			调用 uuidv4 每次都是生成一个新的唯一标识
			如果直接把这个方法的调用交给 userTempId，每次生成的都是唯一值
			没调用一次接口，都会走请求拦截器，每次都会生成一个值，
			服务器返回当前唯一值所对应的购物车列表：空
			
			
		-----------------
		
		
		正确的使用方式：
		
			将第一次生成的 唯一值 保存、存储起来、刷新页面以后还要存在
			
			当发起请求的时候，把值取出来交给拦截器
			
			如果取的时候，没这个唯一值，再次生成即可
			
			
			所以可以使用永久存储 localStorage 进行存储即可
			
			需要将存、取的过程进行封装 ！
			
			
			封装思路：
			
				1. 封装一个模块、模块中定义一个方法
				
				2. 先从本地获取存储的唯一标识
				
				3. 如果本地存在，直接将唯一标识返回接口
				
				4. 如果本地不存在，需要生成唯一标识、存储到本地、返回给方法调用者
				
				5. 将封装的方法，在 request.js 中导入，调用方法，将返回的唯一值，交给请求头
			
			
			
	11. 购物车-商品列表渲染
	
		① 需要 data 中先有数据，所以需要把返回的数据赋值给 data 中的状态
		
		② 找对应的组件，需要遍历区域的结构、v-for
		
		
	12. 购物车-单个商品勾选
	
		思路：
	
			① 点击单选框，获取【变更后】的状态
			
				接口希望接收的选中状态是 0 、1，不是 true 和 false，所以 不能给 checkbox 绑定 v-model
				
				给单选框绑定值的时候，需要绑定 checked ，不能绑定 value
			
			② 看接口文档，封装接口
			
			③ 接口在组件中进行导入
			
			④ 点击单选框对应的事件中，调用 API，传入参数即可
			
		---------------------
		
		优化：
		
			1. 代码
			
			2. 重新赋值优化
			
			
			
			
	13. 购物车-全选功能 (1)
	
	
		所有的商品被选中，全选功能按钮也被选中
		
		
		① 创建一个计算属性：内部返回 布尔值
		
		② 布尔值怎么产生的：判断商品的 isChecked 是否都为 1，如果都为 1 ，返回 true，否则返回 false
		
		③ 直接将计算属性绑定给全选按钮
		
		
		-------------
		
		优化：
		
		点击每个单选按钮选中的状态，在网络比较延迟的时候，不能和全选的选中状态保持同步
		
		本质原因：网络比较慢
		
			在请求发送成功以后，在对单选按钮和全选按钮状态变更
		
			请求发送成功之前，单选按钮是什么状态，就是什么状态，不变更
			
			将原本的状态通过 e.target.checked 赋值给单选框即可
			
			
			
	14. 购物车-全选功能 (2)
	
		在点击全选以后，需要将每个商品更改后的状态需要同步到服务器
		
		思路：
		
			① 点击全选，获取【变更后】的状态 同时需要获取 全部商品的 skuId 组成一个数组
			
			② 准备接口 API
			
			③ 在组件中导入 接口 API，传入参数即可
			
			④ 看一下是否还有需要优化的地方
			
			
		-------------
		
		优化：
		
			网络延迟
			
			遍历获取 skuIds 太繁琐(需要定义一个变量，然后一个个 push)
			
			
			
	15. 购物车-总数与总金额
	
		需要使用计算属性来处理
		
		总数和总金额是已选择商品的
		
		所以需要判断每一项是否是选中的，怎么判断： isChecked
		
		
	
	16. 购物车-删除单个商品
	
		① 给删除绑定点击事件、需要获取要删除的那一个商品的数据
		
		② 准备接口 API
			
		③ 在组件中导入 接口 API，传入参数即可
		
		
		细节
		
		调用接口，将服务器数据删除以后，如果服务器返回删除成功，需要将本地的对应商品也进行删除
		
		
	
	
	
	
	17. 购物车-批量删除勾选的商品
	
	
		① 给删除绑定点击事件、需要获取要删除的那几个商品的数据 [skuId, skuId]
		
		② 准备接口 API
		
		③ 在组件中导入 接口 API，传入参数即可
		
		
		
		细节
		
		调用接口，将服务器数据删除以后，如果服务器返回删除成功，需要将本地的对应商品也进行删除
		
		
		